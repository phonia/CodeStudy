using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace RegularExpress
{
    /**
     * 正则表达式练习
     * 1、特殊的12个文字字符   [ ] \ ^ $ . | ? * + ( )  如果需要将正则表达式中将这些字符用作文字字符，则需要转码‘\+’
     * \t、 \r、 \n tab、回车以及换行字符   widows文本中使用的\r\n换行而Unix用\n
     * 正则表达式的两种工作机制：正则导向、文本导向；正则导向的引擎总是返回最左边的匹配
     * 字符集是由一堆方括号‘【】’包含的字符集和，使用字符集，你可以告诉正则表达式引擎仅仅匹配字符中的一个，如gr[ae]y,可以匹配gray\grey
     *   使用‘-’定义一个字符范围作为字符集如[0-9]匹配0到9之间的单个数字
     *   取反字符集，在 ‘s[^0-9]’匹配除0到9之间数字的字符,注意s之后必须有个一个非0到9之间数字的字符
     *   字符集中的元字符：\代表转义，^代表取反，-代表范围定义，\.代表普通的点而不是通配符，其他常见的元字符在字符集中都是常规字符，如[+*]代表匹配*或者+
     *   字符集的简写：\d代表[0-9],\w代表单词字符，\s代表白字符，根据不同的实现可代表空字符制表以及回车换行符
     *   [\da-fA-F]匹配一个十六进制数字
     *   字符集的重复、取反：[\s]=[^\s],[0-9]+等字符集的重复将会重复整个字符集而不是单个字符
     * 使用?*+进行重复
     *   ?匹配前导字符0或1次，标示前导字符是可选的；+匹配前导字符一次或多次；*匹配前导字符0或多次
     *   限制性重复：\b[1-9][0-9]{3}\b匹配1000~9999之间的数，\b标示单词边界
     *   注意贪婪性：使用重复字符会尽可能匹配到更多的字符串，也就是说并不是匹配到合适的字符串为止，而是匹配到最后一个真确的字符为止
     *      <.+>匹配<EM>fist</EM> 得到的是<EM>first></EM>而不是<EM>和</EM>
     *      用懒惰性取代贪婪性：一个用于修正的方案是用‘+'的懒惰型取代贪婪性，在’+‘紧跟着一个’?'。
     *  使用.匹配几乎任意字符串
     *  字符串开始和结束的锚定
     *      锚定和一般的正则表达式符号不同，它不匹配任何字符串。相反，它们匹配的是符之前或之后的位置。'^'匹配一行字符串第一个字符前的位置
     *      如^a匹配到abc的a而^b不会匹配到abc的b
     *      类似的$匹配字符串中最后一个字符的后面位置，c$匹配abc中的c
     *      锚定的应用：
     *          检校用户输入，输入为整数^\d+$,当输入字符串首尾有多余的空格时可以用^\s*和\s*$来结束
     *          关于$与换行符的关系，由不同的方式实现
     *  单词边界<\b>
     *      单词边界也是一种对位置进行匹配的锚，这种匹配是0长度匹配
     *          在字符串的第一个字符前的位置（如果字符串的第一个字符是一个单词字符）
     *          在字符串的最后一个字符后的位置（如果字符串的最后一个字符是一个单词字符）
     *          在一个单词字符和非单词字符之间，其中非单词字符紧跟在单词字符之后
     *          在一个非单词字符和单词字符之间，其中单词字符紧跟在非单词字符之后
     *      单词字符是可以用\w匹配的字符，非单词字符是可以用\W匹配的字符
     *      非单词边界\B,他要匹配的位置是两个单词字符之间或者两个非单词字符之间
     *      注意单词边界的4中情况，如\bis\b 匹配This island is beautiful中的d is b里的is
     *  选择符
     *      cat|dog，使用选择符是注意考虑正则引擎的导向，如Get|GetValue|Set|SetValue匹配SetValue得到的是Set而不是SetValue
     *      可以改为\bGet|GetValue|Set|SetValue\b可以优化成 \b(Get|Set)(Value)?\b
     *  组与向后引用
     *      把正则表达式的一部分放在园括号内，你可以将他们形成组，然后可以对整个组使用一些正则操作，如重复操作
     *      要注意的是，只有圆括号（）才能用于形成组，[]是字符集，{}限定的重复操作
     *      单用（）定义了一个正则表达式组后，正则引擎则会把被匹配的组按照顺序编号，存入缓存，当对被匹配的组进行香火引用的时候，可以用\d的方式进行应用
     *      \1引用第一个匹配的后向引用组，\2则引用第二个组，以此类推\n则应用第n组，\0则引用整个表达式
     *      <([A-Z][A-Z0-9]*)[^>]*>.*?</\1>用于匹配<B>This is a test</B> 后向引用组
     *      可以对相同的后向引用组进行多次引用
     *      一个后向引用不能用于它自身，[abc]\1是错误的
     *      后向引用不能用于字符集内部(a)[\1b]中的\1不能表示后向引用，在字符集的内部可以被解释为八进制形式的转码
     *      向后引用会降低引擎的速度，因为它需要存储匹配的组
     *      组的命名和引用：不推荐使用
     *  正则表达式的匹配模式
     *      /i是正则表达式对大小写不敏感；/s开启单行模式，即.匹配新行符；/m开启多行模式，即^和$匹配新行符的前面和后面的位置——如何开启这些模式
     *  原子组与防止回溯
     *      在一些特殊情况下，因为回溯会使得引擎的效率及其低下
     *      让我们看一个例子：要匹配这样的字串，字串中的每个字段间用逗号做分隔符，第12个字段由P开头
     *      我们容易想到这样的正则表达式^(.*?,){11}P这个正则表达式在正常情况下工作很好，但是在极端的情况下，如果第12字符不是P开头，则会发生灾难性的回溯。
     *      如果搜索的字串为1,2,3,4,5,6,7,8,9,10,11,12,13首先，正则表达式一直成功匹配到第12字符，这时，前面的正则表达式消耗了在这之前的字串，到了下一个字串
     *      P并不匹配12,所以引擎进行回溯。
     *      如何阻止这样的回溯
     *          一种简单的方案是尽可能的使匹配精确，用取反字符集代替点号
     *          另一种就是使用原子组：原子组的目的是使正则引擎失败的更快一点，因此可以有效的阻止海量回溯
     *          原子组的语法是^(?>正则表达式)。位于(?>)之间的所有表达式都会被认为是一个单一的正则符号。一旦失败，引擎将会回溯到原子组前面的正则表达式部分
     *          如^(?>(.*?,){11})P
     *  向前查看与向后查看（没有完全理解清楚）
     *      向前查看以及向后查看并不消耗任何字符串
     *  表达式中的条件测试
     *      条件测试的语法(?ifthen|else)其中if部分是可以向前向后查看表达式，如果改为向前则变为(?(?=regex)then|else)
     * **/

    /*
     *  注意：
     *      .可以匹配大多数字符包括单个字符、字母、数字等，比如-_~!@#$%^&*()_+等，可以匹配空白符，但是制表换行回车不一定匹配
     *      [^abc]匹配到一个字符位，该字符不为abc中的任何一个
     *      匹配元字符使用转义\,如\. \\等（\反斜杠）
     *      \r \n \t \f \v
     *      使用转义\使得元字符编程不同字符\\ \. \[等，使得普通字符编程特殊字符\d  \D
     *      匹配字符数字下划线[a-zA-Z0-9_]=\w,[^a-zA-A0-9_]=\W
     *      空字符\s=[\r\n\t\f\v],\S=[^\r\n\t\f\v]
     *      -只在在[]区间内是原字符;.在[]外才是元字符所以[\w\.]=[\w.]
     *      邮箱的reg需要考虑_.、首字符以及多级域名的情况
     *      重复匹配时的贪婪与惰性匹配：*、*?以此类推
     *      \b匹配在边界的字符：
     *          边界的定义：通常情况下，以空格、段落首行、段落末尾、逗号、句号、-等符号作为边界
     *              当你对一个普通字符，比如‘s'设定边界的时候，它的边界是诸如空格、分隔符、逗号、句号等
     *              当对一个边界，比如分隔符-或者,等设定边界的时候，他的边界是普通字符
     *      \B匹配不在边界的字符，与边界匹配类似
     *      匹配文本边界
     *      匹配子模式：对整体而非单个字符的重复
     *      选择匹配：|
     *      嵌套子模式
     *      向后引用：慎用
     *      向前后预查：慎用
     * 
     * ****/
    class Program
    {
        static void Main(string[] args)
        {
        }
    }
}
